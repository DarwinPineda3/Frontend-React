import {
  Box,
  Button,
  Chip,
  FormControl,
  FormHelperText,
  Grid,
  InputLabel,
  MenuItem,
  Select,
  TextField,
  Typography,
  useTheme,
} from '@mui/material';
import { useFormik } from 'formik';
import React, { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { useTranslation } from 'react-i18next';
import DashboardCard from 'src/components/shared/DashboardCard';
import { useDispatch } from 'src/store/Store';
import { editVulnerability } from 'src/store/vulnerabilities/ManagementVulnSlice';
import {
  AcceptedMimeTypes,
  VulnerabilityResponse,
} from 'src/types/vulnerabilities/vulnerabilityManagementType';
import { formatCurrency } from 'src/utils/formatters';
import * as Yup from 'yup';

interface Props {
  vulnerability: VulnerabilityResponse;
  onSubmit: (message: string, severity: 'success' | 'info' | 'warning' | 'error') => void;
}

const ManagedVulnerabilityForm: React.FC<Props> = ({ vulnerability, onSubmit }) => {
  const dispatch = useDispatch();
  const { t } = useTranslation();
  const theme = useTheme();

  const [estimatedBudget, setEstimatedBudget] = useState<number>(
    vulnerability?.vulnerability?.estimated_budget || 0,
  );
  const [evidenceFiles, setEvidenceFiles] = useState<any[]>(vulnerability?.evidence_files || []);

  // Formik setup with Yup validation schema
  const formik = useFormik({
    initialValues: {
      responsible: vulnerability?.vulnerability?.responsible || '',
      role: vulnerability?.vulnerability?.role || '',
      notes: vulnerability?.vulnerability?.notes || '',
      work_plan: vulnerability?.vulnerability?.work_plan || '',
      compensatory_controls: vulnerability?.vulnerability?.compensatory_controls || '',
      recategorization: vulnerability?.vulnerability?.recategorization || '',
      estimated_budget: estimatedBudget,
      estimated_closure_date: vulnerability?.vulnerability?.estimated_closure_date
        ? new Date(vulnerability?.vulnerability?.estimated_closure_date).toISOString().split('T')[0]
        : '',
      evidence: vulnerability?.vulnerability?.evidence || [],
    },
    validationSchema: Yup.object({
      responsible: Yup.string().required(`${t('vulnerabilities.management.required_field')}`),
      role: Yup.string().required(`${t('vulnerabilities.management.required_field')}`),
      notes: Yup.string().required(`${t('vulnerabilities.management.required_field')}`),
      work_plan: Yup.string().required(`${t('vulnerabilities.management.required_field')}`),
      compensatory_controls: Yup.string().required(
        `${t('vulnerabilities.management.required_field')}`,
      ),
      recategorization: Yup.string().required(`${t('vulnerabilities.management.required_field')}`),
      estimated_budget: Yup.number()
        .required(`${t('vulnerabilities.management.required_field')}`)
        .positive(),
      estimated_closure_date: Yup.string()
        .required(`${t('vulnerabilities.management.required_field')}`)
        .test('is-future', `${t('vulnerabilities.management.date_in_past')}`, (value) => {
          if (!value) return false;
          const selectedDate = new Date(value);
          const currentDate = new Date();
          return selectedDate >= currentDate;
        }),
    }),
    onSubmit: async (values) => {
      const formData = new FormData();

      formData.append('name', vulnerability?.vulnerability?.name || '');
      formData.append('severity', vulnerability?.vulnerability?.severity?.toString() || '');
      formData.append('type', vulnerability?.vulnerability?.type || '');
      formData.append('vulnerability_id', vulnerability?.vulnerability?.vulnerability_id || '');
      formData.append('id', vulnerability?.vulnerability?.id?.toString() || '');
      formData.append('creation_time', vulnerability?.vulnerability?.creation_time || '');
      formData.append('qod', vulnerability?.vulnerability?.qod || '');
      formData.append('hosts', vulnerability?.vulnerability?.hosts || '');
      formData.append('port', vulnerability?.vulnerability?.port || '');
      formData.append('tool', vulnerability?.vulnerability?.tool || '');
      formData.append('description', vulnerability?.vulnerability?.description || '');
      formData.append('report_id', vulnerability?.vulnerability?.report_id || '');
      formData.append('report_date', vulnerability?.vulnerability?.report_date || '');
      formData.append('last_revision_date', vulnerability?.vulnerability?.last_revision_date || '');
      formData.append('closure_date', vulnerability?.vulnerability?.closure_date || '');
      formData.append('closure_reason', vulnerability?.vulnerability?.closure_reason || '');
      formData.append('status', vulnerability?.vulnerability?.status || '');

      formData.append('responsible', values.responsible || '');
      formData.append('role', values.role || '');
      formData.append('notes', values.notes || '');
      formData.append('work_plan', values.work_plan || '');
      formData.append('compensatory_controls', values.compensatory_controls || '');
      formData.append('recategorization', values.recategorization || '');
      formData.append(
        'estimated_budget',
        values.estimated_budget ? values.estimated_budget.toString() : '',
      );
      formData.append('estimated_closure_date', values.estimated_closure_date || '');

      if (Array.isArray(values.evidence) && values.evidence.length > 0) {
        values.evidence.forEach((file: File) => {
          formData.append('evidence', file);
        });
      }

      try {
        await dispatch(editVulnerability(formData));
        onSubmit(
          `${t('vulnerabilities.management.managed_vulnerability_updated_successfully')}`,
          'success',
        );
      } catch (error) {
        console.error('Error al enviar vulnerabilidad:', error);
        onSubmit(`${t('vulnerabilities.management.managed_vulnerability_updated_error')}`, 'error');
      }
    },
  });
  const acceptedMimeTypes: AcceptedMimeTypes = {
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
    'application/vnd.ms-excel': ['.xls'],
    'image/*': ['.png', '.gif', '.jpeg', '.jpg'],
    'application/msword': ['.doc'],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
    'application/vnd.ms-powerpoint': ['.ppt'],
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': ['.pptx'],
    'text/plain': ['.txt'],
    'application/pdf': ['.pdf'],
  };

  const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB en bytes
  const onDrop = useCallback(
    (acceptedFiles: File[]) => {
      const validFiles = acceptedFiles.filter((file) => {
        const fileType = file.type;
        const fileExtension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();

        const isValidType =
          Object.keys(acceptedMimeTypes).includes(fileType) &&
          acceptedMimeTypes[fileType].includes(fileExtension);

        const isValidImage =
          fileType.startsWith('image/') && acceptedMimeTypes['image/*'].includes(fileExtension);

        const isValidSize = file.size <= MAX_FILE_SIZE;
        console.log(isValidImage, isValidSize, isValidType);

        if (!isValidType && !isValidImage) {
          formik.setFieldError('evidence', `${t('vulnerabilities.management.invalid_files')}`);
          console.log(formik.errors.evidence);
          console.log('entro aqui 1');

          return false;
        }

        if (!isValidSize) {
          formik.setFieldError(
            'evidence',
            `${t('vulnerabilities.management.file_too_large', {
              name: file.name,
              size: MAX_FILE_SIZE,
            })}`,
          );
          console.log(formik.errors.evidence);
          console.log('entro aqui 2');

          return false;
        }
        console.log('entro aqui 3');

        return true;
      });
      console.log(formik.errors.evidence);

      if (validFiles.length > 0) {
        setEvidenceFiles([]);
        formik.setFieldValue('evidence', validFiles);
        formik.setFieldError('evidence', '');
      }
    },
    [formik],
  );

  const { acceptedFiles, getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: acceptedMimeTypes,
    maxFiles: 1,
  });

  const files = [
    ...(Array.isArray(evidenceFiles) && evidenceFiles.length > 0
      ? evidenceFiles.map((file, index) => (
          <Box
            key={index + 1}
            display="flex"
            alignItems="center"
            py={1}
            mt={2}
            sx={{ borderTop: `1px solid ${theme.palette.divider}` }}
            justifyContent="space-between"
          >
            <Typography variant="body1" fontWeight="500">
              {file.name}{' '}
            </Typography>
            <Chip color="primary" label={`${file.type} | ${file.size} Bytes`} />
          </Box>
        ))
      : []),

    ...acceptedFiles.map((file: File, i) => (
      <Box
        key={i}
        display="flex"
        alignItems="center"
        py={1}
        mt={2}
        sx={{ borderTop: `1px solid ${theme.palette.divider}` }}
        justifyContent="space-between"
      >
        <Typography variant="body1" fontWeight="500">
          {file.name}{' '}
        </Typography>
        <Chip color="primary" label={`${file.type} | ${file.size} Bytes`} />
      </Box>
    )),
  ];

  const recategorizationOptions = [
    { value: 'CRITICAL', label: `${t('vulnerabilities.management.critical')}` },
    { value: 'HIGH', label: `${t('vulnerabilities.management.high')}` },
    { value: 'MEDIUM', label: `${t('vulnerabilities.management.medium')}` },
    { value: 'LOW', label: `${t('vulnerabilities.management.low')}` },
  ];

  const handleEstimatedBudgetChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value;

    value = value.replace(/[^\d.]/g, '');

    const parsedValue = parseFloat(value);

    if (!isNaN(parsedValue)) {
      formik.setFieldValue('estimated_budget', parsedValue);

      const formattedValue = `$ ${(parsedValue / 100).toLocaleString('es-ES', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      })}`;

      e.target.value = formattedValue;
    }
  };

  return (
    <DashboardCard
      title={t('vulnerabilities.management.vulnerability_management_form')!}
      subtitle={t('vulnerabilities.management.vulnerability_management_form_subtitle')!}
    >
      <Box component="form" onSubmit={formik.handleSubmit} noValidate>
        <Grid container spacing={2}>
          {/* Responsible */}
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.responsible')}
              name="responsible"
              value={formik.values.responsible}
              onChange={formik.handleChange}
              error={formik.touched.responsible && Boolean(formik.errors.responsible)}
              helperText={formik.touched.responsible && formik.errors.responsible}
              margin="normal"
            />
          </Grid>

          {/* Role */}
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.role')}
              name="role"
              value={formik.values.role}
              onChange={formik.handleChange}
              error={formik.touched.role && Boolean(formik.errors.role)}
              helperText={formik.touched.role && formik.errors.role}
              margin="normal"
            />
          </Grid>

          {/* Estimated Closure Date */}
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.estimated_closure_date')}
              name="estimated_closure_date"
              type="date"
              value={formik.values.estimated_closure_date}
              onChange={formik.handleChange}
              error={
                formik.touched.estimated_closure_date &&
                Boolean(formik.errors.estimated_closure_date)
              }
              helperText={
                formik.touched.estimated_closure_date && formik.errors.estimated_closure_date
              }
              margin="normal"
              InputLabelProps={{
                shrink: true,
              }}
            />
          </Grid>

          {/* Recategorization */}
          <Grid item xs={12} sm={6}>
            <FormControl
              fullWidth
              margin="normal"
              error={formik.touched.recategorization && Boolean(formik.errors.recategorization)}
            >
              <InputLabel>{t('vulnerabilities.management.recategorization')}</InputLabel>
              <Select
                label={t('vulnerabilities.management.recategorization')}
                name="recategorization"
                value={formik.values.recategorization}
                onChange={formik.handleChange}
              >
                {recategorizationOptions.map((option) => (
                  <MenuItem key={option.value} value={option.value}>
                    {option.label}
                  </MenuItem>
                ))}
              </Select>
              <FormHelperText>
                {formik.touched.recategorization && formik.errors.recategorization}
              </FormHelperText>
            </FormControl>
          </Grid>

          {/* Estimated Budget */}
          <Grid item xs={12} sm={12}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.estimated_budget')}
              name="estimated_budget"
              value={formatCurrency(formik.values.estimated_budget)}
              onChange={handleEstimatedBudgetChange}
              error={formik.touched.estimated_budget && Boolean(formik.errors.estimated_budget)}
              helperText={formik.touched.estimated_budget && formik.errors.estimated_budget}
              margin="normal"
            />
          </Grid>

          {/* Work Plan */}
          <Grid item xs={12}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.work_plan')}
              name="work_plan"
              value={formik.values.work_plan}
              onChange={formik.handleChange}
              error={formik.touched.work_plan && Boolean(formik.errors.work_plan)}
              helperText={formik.touched.work_plan && formik.errors.work_plan}
              margin="normal"
              multiline
              rows={4}
            />
          </Grid>

          {/* Compensatory Controls */}
          <Grid item xs={12}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.compensatory_controls')}
              name="compensatory_controls"
              value={formik.values.compensatory_controls}
              onChange={formik.handleChange}
              error={
                formik.touched.compensatory_controls && Boolean(formik.errors.compensatory_controls)
              }
              helperText={
                formik.touched.compensatory_controls && formik.errors.compensatory_controls
              }
              margin="normal"
              multiline
              rows={4}
            />
          </Grid>

          {/* Notes */}
          <Grid item xs={12}>
            <TextField
              fullWidth
              label={t('vulnerabilities.management.notes')}
              name="notes"
              value={formik.values.notes}
              onChange={formik.handleChange}
              error={formik.touched.notes && Boolean(formik.errors.notes)}
              helperText={formik.touched.notes && formik.errors.notes}
              margin="normal"
              multiline
              rows={4}
            />
          </Grid>

          {/* Evidence */}
          <Grid item xs={12}>
            <Typography variant="h5">{t('vulnerabilities.management.evidence')}</Typography>

            <Box
              mt={3}
              fontSize="12px"
              sx={{
                backgroundColor: 'white',
                color: 'primary.main',
                padding: '30px',
                textAlign: 'center',
                border: `1px dashed`,
                borderColor: 'primary.main',
              }}
              {...getRootProps({ className: 'dropzone' })}
            >
              <input {...getInputProps()} />
              <p>{t('malware.message_select_files')}</p>
            </Box>
            {formik.errors.evidence && formik.touched.evidence && (
              <Box mt={2} color="error.main" fontSize="12px">
                <Typography variant="body2">{formik.errors.evidence} </Typography>
              </Box>
            )}
            <Box mt={2}>
              <Typography variant="h6" fontSize="15px">
                {t('vulnerabilities.management.file')}
              </Typography>
              <Box>{files}</Box>
            </Box>
          </Grid>
        </Grid>

        <Box display="flex" justifyContent="flex-end" mt={2}>
          <Button type="submit" variant="contained" color="primary">
            {t('vulnerabilities.management.submit')}
          </Button>
        </Box>
      </Box>
    </DashboardCard>
  );
};

export default ManagedVulnerabilityForm;
